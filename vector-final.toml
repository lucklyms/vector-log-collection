# Vector 統一日誌收集配置 - 最終版本

[api]
  enabled = true
  address = "0.0.0.0:8686"

# ==================== 數據源 ====================

# HTTP 接收 (帶 Token 認證)
[sources.http_logs]
  type = "http_server"
  address = "0.0.0.0:8080"
  decoding.codec = "json"

  # 設定需要的認證 Header
  # 客戶端需要在請求中加入: Authorization: Bearer YOUR_SECRET_TOKEN
  headers = ["Authorization"]

# Syslog UDP
[sources.syslog_udp]
  type = "syslog"
  mode = "udp"
  address = "0.0.0.0:5514"

# Syslog TCP
[sources.syslog_tcp]
  type = "syslog"
  mode = "tcp"
  address = "0.0.0.0:5601"

# IIS 日誌文件
[sources.iis_logs]
  type = "file"
  include = ["/iis-logs/**/*.log"]
  read_from = "beginning"

# Apache 日誌
[sources.apache_logs]
  type = "file"
  include = ["/apache-logs/**/*.log"]
  read_from = "beginning"

# 應用日誌
[sources.app_logs]
  type = "file"
  include = ["/app-logs/**/*.log"]
  read_from = "beginning"

# ==================== 日誌轉換 ====================

# Token 驗證 - 檢查 Authorization header
[transforms.validate_token]
  type = "filter"
  inputs = ["http_logs"]
  condition = '''
    # 從 headers 中取得 Authorization
    auth = .headers.authorization ?? ""

    # 支援多個 token（可以為不同的 agent 設置不同 token）
    valid_tokens = [
      "Bearer my-secret-token-2024",
      "Bearer agent-token-abc123",
      "Bearer production-token-xyz789"
    ]

    # 檢查 token 是否有效
    includes(valid_tokens, auth)
  '''

# HTTP 日誌（自動提取來源 IP）
[transforms.tag_http]
  type = "remap"
  inputs = ["validate_token"]
  source = '''
    .log_type = "http"
    .collected_at = now()

    # HTTP server 會在 metadata 中提供來源 IP
    # 先保留，之後從連線資訊中提取

    # 移除敏感的 Authorization header，避免記錄到日誌中
    del(.headers.authorization)
  '''

# Syslog
[transforms.tag_syslog]
  type = "remap"
  inputs = ["syslog_udp", "syslog_tcp"]
  source = '''
    .log_type = "syslog"
    .collected_at = now()
  '''

# 文件日誌
[transforms.tag_files]
  type = "remap"
  inputs = ["iis_logs", "apache_logs", "app_logs"]
  source = '''
    .log_type = "file"
    .collected_at = now()
  '''

# ==================== 輸出 ====================

# 重新整理日誌格式
[transforms.format_logs]
  type = "remap"
  inputs = ["tag_http", "tag_syslog", "tag_files"]
  source = '''
    .source_ip = .agent_ip || .agent_hostname || .host || "unknown"

    # 處理時間戳
    ts = .timestamp
    if is_timestamp(ts) {
      .log_time = format_timestamp!(ts, format: "%Y-%m-%d %H:%M:%S")
    } else if is_string(ts) {
      # 嘗試解析字串為 timestamp 再格式化
      parsed = parse_timestamp(ts, format: "%+") ?? null
      if parsed != null {
        .log_time = format_timestamp!(parsed, format: "%Y-%m-%d %H:%M:%S")
      } else {
        .log_time = ts
      }
    } else {
      .log_time = to_string!(ts)
    }

    # 安全處理 message 欄位
    if exists(.message) {
      .log_message = to_string!(.message)
      # 移除原始 message 避免冗余
      del(.message)
    } else {
      .log_message = ""
    }

    # 智能提取日誌中的相關 IP
    # 1. SSH 登入/斷線
    if contains(.log_message, "sshd") {
      parsed = parse_regex(.log_message, r'from (?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})') ?? null
      if parsed != null {
        .remote_ip = parsed.ip
      }
    }

    # 2. Apache/Nginx access log (第一個 IP 通常是客戶端 IP)
    if contains(.log_message, "GET") || contains(.log_message, "POST") || contains(.log_message, "HTTP") {
      parsed = parse_regex(.log_message, r'^(?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})') ?? null
      if parsed != null {
        .remote_ip = parsed.ip
      }
    }

    # 3. 通用 IP 提取（當上述規則都不匹配時，提取第一個出現的 IP）
    if !exists(.remote_ip) {
      parsed = parse_regex(.log_message, r'(?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})') ?? null
      if parsed != null {
        .remote_ip = parsed.ip
      }
    }

    .original_timestamp = .timestamp
  '''

[sinks.console]
  type = "console"
  inputs = ["format_logs"]
  encoding.codec = "json"

[sinks.file_output]
  type = "file"
  inputs = ["format_logs"]
  path = "/var/log/vector/unified-%Y-%m-%d.log"
  encoding.codec = "json"
